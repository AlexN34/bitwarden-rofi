#!/bin/bash
# Helper functions

# Extract item or items matching .name, including deduplication
# $1: item name, prepended or not with deduplication mark
array_from_name() {
  item_id="$(echo "$item" | cut -d ':' -f 1)"
  item_name="$(echo "$1" | sed "s/$DEDUP_MARK//" | sed 's/^[ \t]*//;s/[ \t]*$//' )"
  echo "$ITEMS" | jq -r ". | map(select((.name == \"$item_name\") and (.type == $TYPE_LOGIN or .type == $TYPE_NOTE or has( \"username\" ) or has( \"note\" ))))"
}

# TODO array_from_source
# compare to name + source value
array_from_source() {
    if [ "$2" == "lastpass" ]; then
        # echo "chose lpass"
        items_to_use="$lpass_items"
    else
        # echo "chose bw"
        items_to_use="$ITEMS"
    fi
    echo "$items_to_use" | jq -r --argjson var "$1" '. | map(select((.name == $var.name) and (.source == $var.source)))'
}

# Extract item matching .id
# $1: string starting with ".id:"
array_from_id() {
  echo "$ITEMS" | jq -r ". | map(select(.id == \"$1\"))"
}

# Count the number of items in an array. Return true if more than 1 or none
# $1: Array of items
not_unique() {
  item_count=$(echo "$1" | jq -r '. | length')
  ! [[ $item_count -eq 1 ]]
}

# Pipe a document and deduplicate lines.
# Mark those duplicated by prepending $DEDUP_MARK
dedup_lines() {
  sort | uniq -c \
  | sed "s/^\s*1 //" \
  | sed -r "s/^\s*[0-9]+ /$DEDUP_MARK/"
}


# Get get_filter(src, action)
# src - lpass, bw
# action - show, show_full, filter, array_from_id, array_from_name

# TODO
# remove special cases for each items
# access global items instead of lpass_items/other (or not?)
# on get_session_key - checked if logged in to lpass too
# update ask password to login to lpass if not already
# load_items - load both with src
# lpass foreach category
# show_items - show both with new filter for both
# lpass - only ls on sync, output alll ids?
# add feature - save last search state
